# 5.2 比特币整合

## 概述

比特币是一种基于开源 P2P 协议的去中心化数字货币。比特币使用未使用的交易输出（UTXO）会计模型，即交易创建输出，这些输出用作创建新交易输出的其他交易的输入。一个 UTXO 总是被一个事务完全消耗掉。

比特币是一个不支持智能合约的支付网络。通过互联网计算机对比特币的智能合约支持增加了巨大的价值：它利用比特币网络作为世界数字黄金储备和互联网计算机作为安全有效执行智能合约的平台的综合优势。这种集成将成为可能的一类应用程序是去中心化金融（DeFi）应用程序，目前只能使用需要额外受信任实体的打包比特币来实现。此外，比特币可用于支付互联网计算机上的任何服务，从而开辟了无穷无尽的应用场景。

互联网计算机与比特币区块链集成，目标是通过两个区块链的直接、“去信任”集成，为比特币提供强大的智能合约功能。在这种情况下，“不信任”意味着除了信任比特币网络和互联网计算机的正确运行之外，不需要任何信任假设。换句话说，不能有额外的参与方，例如桥梁或其他类型的中介，从而实现更清洁、更安全的集成。在比特币和互联网计算机的这种无需信任的集成中，容器子可以直接将比特币保存在比特币区块链上。

这种直接集成基于以下特性：

- 容器子可以有比特币地址（因此可以直接在比特币区块链上接收和持有比特币）。
- 容器可以访问它们控制的地址的 UTXO 集。
- 容器子可以安全地签署比特币交易。
- 容器子可以向比特币网络提交比特币交易。

集成的不信任方面依赖于阈值 ECDSA 协议，该协议使子网能够根据容器请求的秘密共享私钥计算 ECDSA 签名。通过该协议，每个容器都可以“控制”大量可派生的 ECDSA 密钥并为其获取签名，从而使容器能够以安全的方式直接在比特币区块链上接收、持有和转移比特币。自然，容器必须能够检索与其比特币地址关联的 UTXO。为此，互联网计算机直接从比特币网络中提取区块。下面将更详细地探讨这种集成的底层架构。

## 架构

在本节中，我们将介绍与比特币区块链直接集成的高级架构。集成更改并在互联网计算机 (IC) 协议栈的每一层添加组件。

[![img](https://mywikis-wiki-media.s3.us-central-1.wasabisys.com/internetcomputer/thumb/Bitcoin_integration_architecture.png/900px-Bitcoin_integration_architecture.png)](https://wiki.internetcomputer.org/wiki/File:Bitcoin_integration_architecture.png)

比特币集成架构的高级概述。

*比特币容器*是在执行层作为副本的一部分实现的虚拟容器，它公开了用于查询 UTXO 集和提交交易的 API 。任何给定比特币地址的 UTXO 集和余额分别通过函数get_utxos和get_balance可用。使用send_transaction函数 将比特币交易发送到比特币网络。

比特币容器为 UTXO 集提供服务需要将比特币块从比特币网络的节点拉入 IC，以提取交易输入和输出，并更新未使用的交易输出 (UTXO) 集。这需要一个跨越 IC 协议栈所有层的架构，并且还包括副本外部的新组件。

比特币容器维护一组最近的比特币块、整个 UTXO 集，以及容器提交的一组传出交易。UTXO 集和最近的块用于响应容器的 UTXO 查询。

比特币适配器是副本外部的沙盒操作系统级进程，它使用比特币的对等发现协议随机连接到多个比特币节点。比特币适配器同步比特币网络的区块头和区块。比特币适配器还维护比特币网络区块的最新视图，并根据请求向 IC 协议栈提供区块。

在每一轮 IC 中，作为共识层核心组件的活跃区块制造者向网络层请求新的比特币区块。网络层检索比特币容器的部分状态，包括比特币容器维护的最近比特币块的标头以及传出交易。这两项都用作向比特币适配器发送比特币块请求的参数。比特币适配器将接收到的块散列与其最近的比特币网络视图相匹配，如果它持有一个块是通过散列表示的块之一的后继块，则返回该块。此外，它将请求中收到的交易添加到队列中，以便将传出交易异步提交到比特币网络。如果比特币适配器返回一个块，

假设在当前的 IC 协议轮次中已经提出了一个包含比特币块的 IC 块。这个 IC 块像往常一样被扩散到子网节点，需要经过公证和最终确定过程。公证过程针对比特币集成进行了扩展：每个副本对 IC 块中包含的比特币块执行确定性有效性检查。至关重要的是，只有在保证该块将被所有诚实副本成功验证的情况下，块制造者才提出一个块，否则子网的共识可能会失败，从而导致整个 IC 块被丢弃。

一旦具有比特币块有效负载的 IC 块已成功验证，最终确定将继续进行，无需更改。一旦区块最终确定，比特币有效负载需要在消息路由层中提取并发布到相应的子网队列以执行。当比特币块到达执行层时，它由执行层的 BTC 容器执行：该块被验证，其对比特币区块链的视图相应更新。

创建比特币交易需要为每个用作交易输入的 UTXO 计算一个 ECDSA 签名。容器可以从作为专用 ECDSA 签名子网的一部分实施的阈值 ECDSA API 请求 ECDSA 签名。最初将部署一个这样的子网，如果需求增加，将来可能会提供多个签名子网。图 1 以简化的方式显示了阈值 ECDSA 功能，它是支持比特币的子网的一部分，而不是位于单独的子网中。阈值 ECDSA API 使容器可以请求 ECDSA 签名，该签名由 ECDSA 子网的副本基于秘密共享私钥联合计算。

## 技术细节

如上一节所述，容器与（虚拟）比特币容器交互以利用比特币集成 API。比特币容器又依赖于比特币适配器，它是与比特币网络交互的组件。在本节中，提供了有关各个组件的技术细节，从比特币适配器自下而上开始。

请注意，[开发者预览版中](https://wiki.internetcomputer.org/wiki/Bitcoin_integration#Developer_Preview)**没有**实现一些技术细节，这将在下一节中讨论。例如，不执行几个有效性检查。这些遗漏对于本地测试环境来说并不重要。

### 比特币适配器

比特币适配器与比特币网络交互以获取区块头和区块，并发布由容器发行的比特币交易。

#### 连接到比特币节点

默认情况下，比特币适配器连接到 8 个随机选择的比特币节点，但连接数是可配置的。为了确保每个副本的比特币适配器以高概率连接到不同的随机集，比特币适配器向种子节点查询地址，直到它收到至少 1000 个地址，并从这些地址中随机选择节点，直到所需数量的已建立连接。实验表明，这个过程导致每个副本的比特币适配器连接到大部分不同的地址。

#### 状态

比特币适配器旨在维持以下状态：

- 所有比特币区块头。
- 比特币块的缓存，它期望比特币容器接下来请求。
- 用于广告但尚未传输到比特币节点的传出交易的缓存。

最初，适配器没有任何块头并且缓存是空的。

#### 比特币适配器在运行

当比特币适配器启动时，它会连接到比特币节点并开始从创世中拉入块头，直到它赶上。对于每个下载的块头，比特币适配器执行以下检查：

- 块头是格式良好的，即它可以被解析为一个正确的块头。
- 前一个块字段指向一个本地可用的块头。
- 根据难度目标，块头中的哈希工作就足够了。
- 区块头中的时间戳大于[前 11 个区块的中值](https://en.bitcoin.it/wiki/Block_timestamp)。

在收到来自比特币容器的消息之前，缓存一直是空的。定期，比特币容器发送一个最近区块头的区块头哈希列表，它已经拥有完整的区块（包含所有交易）。有关发送哪些块头哈希的详细信息，请参阅有关比特币容器的部分。

比特币适配器检查它是否有任何比特币容器丢失的块，并以包含丢失块的消息进行响应，优先考虑具有较低高度的块。可以在一条消息中返回多个块，最大软上限为 2 MB，确保即使其大小超过 2 MB，也可以返回至少一个比特币块。这个上限意味着对于大小通常超过 1 MB 的最近块，只返回一个块（和块头）。在一条消息中发送多个块的能力对于更快地摄取旧块很有用，因为它们要小得多。

如果比特币适配器的缓存中没有丢失的块，它会立即返回一条空消息，以免延迟共识。在准确了解比特币容器的状态后，比特币适配器会下载下一个丢失的块，以便在比特币容器的未来请求中将它们打包到返回消息中。由于比特币适配器不跟踪交易，它无法验证接收到的区块中交易的有效性。但是，为了防止向比特币容器发送无效块垃圾邮件，它会执行一些基本检查：

- 该块是格式良好的，即它可以被解析为一个正确的比特币块。
- Merkle 树根哈希对应于相应区块头中的哈希。

一旦接收到的一组块头哈希表明比特币容器已接收到块，块就会从缓存中删除。

当比特币适配器接收到出站交易时，它们被放置在交易缓存中并被通告给比特币网络。一旦交易被传输到连接的比特币节点，交易就会从缓存中删除。

### 通过共识

从技术上讲，只要复制品被选为下一个（IC）块制造商，就会查询复制品的比特币适配器以获取比特币块。当比特币适配器的响应包含一个或多个比特币块时，Consensus 会调用一个函数来检查比特币块的有效性，然后再将它们放入 IC 块中。确保有效性检查导致子网中所有副本的结果一致很重要，否则整个 IC 块可能会如前所述被丢弃。因此，有效性检查必须是一个确定性函数，即不能考虑本地时间和比特币适配器的本地可用状态等因素。执行以下有效性检查：

- 块头是格式良好的，即它可以被解析为一个正确的块头。
- 该块是格式良好的，即它可以被解析为一个正确的比特币块。
- Merkle 树根哈希对应于相应区块头中的哈希。

同样，交易在这个阶段没有得到验证。

一旦 IC 块通过共识（和消息路由），比特币块（和相应的块头）就会被提供给比特币容器以供摄取。

### 比特币容器

比特币容器是一个虚拟容器，类似于[管理容器](https://smartcontracts.org/docs/interface-spec/index.html#ic-management-canister)，这意味着它在其他容器看来就像一个常规容器，但实际上它是副本本身的一部分。比特币集成 API 通过比特币容器提供，以使其他容器能够整合比特币功能。

#### 状态

比特币容器存储以下状态：

- 从创世到某个区块高度 h 的完整 UTXO 集。
- 包括从高度 h 开始的块头的块。
- 传出事务集。

由于比特币容器不存储交易的完整历史，它必须决定何时可以安全地丢弃一个块，只依赖于它维护的 UTXO 集中的信息。

由于存在长期分叉的风险，比特币容器不使用确认计数来确定何时丢弃一个块。相反，它使用了一个稍微复杂一点的概念，我们称之为*稳定性*。简单来说，如果有一定数量的后续块，我们认为一个块是*稳定的，降低了该块将来被丢弃的风险，并且任何分叉的尖端也至少落后相同数量的块。*更正式地说，如果表示自创世以来`h(b)` 块的前导块的数量，并表示从块开始的最长后继路径的长度，则稳定性定义如下。 `b``d(b)``b`

```
定义（𝜹-稳定性）：令 B 表示本地可用块的集合。
对于参数 𝜹>0，如果以下条件成立，我们就说块 b 是 𝜹 稳定的：
* d(b) ≥ 𝜹
* ∀ b' ∈ B \ {b}, h(b') = h(b): d(b) - d(b') ≥ 𝜹
```

比特币容器配置了 144 的稳定性阈值𝜹，即，如果没有分叉，比特币容器将所有区块保留大约一天（平均每 10 分钟一个区块）。一旦一个块变得𝜹-stable，交易就会被应用到 UTXO 集并且该块被丢弃。因此，稳定性用于定义上述状态描述中提到的截止块高度h。所有稳定性低于阈值的块都被认为是*不稳定*的。

#### 运行中的比特币容器

当从比特币适配器请求更新时，比特币容器向比特币适配器发送一条包含所有不稳定块的哈希值的消息，比特币适配器使用哈希来确定比特币容器丢失了哪些块（如果有）。当从比特币适配器接收块和块头时，对每个块/块头对执行以下有效性检查：

- 块头是格式良好的，即它可以被解析为一个正确的块头。
- 根据难度目标，块头中的哈希工作就足够了。
- 块头指向一个已知的前任。
- 该块是格式良好的，即它可以被解析为一个正确的比特币块。
- Merkle 树根哈希对应于相应区块头中的哈希。
- 所有交易都是有效的，即签名是正确的，只有未使用的输出被消耗。
- 区块头中的时间戳大于[前 11 个区块的中值](https://en.bitcoin.it/wiki/Block_timestamp)。

如果验证成功，则将该区块添加到不稳定区块列表中。此外，如果一个区块因此变为𝜹-stable，则 UTXO 集会根据该区块中的交易进行更新，并丢弃该区块。

如上所述，比特币容器公开了以下 API：

- get_utxos：该函数返回给定比特币地址的未使用交易输出（UTXO）。
- get_balance：该函数返回给定比特币地址的余额。
- send_transaction：该函数将给定的交易发送到比特币网络。

支持以下地址格式：

- 支付给公钥哈希（P2PKH）
- 支付脚本哈希 (P2SH)
- 付费见证公钥哈希 (P2WPKH)
- 付费见证脚本哈希 (P2WSH)

可以在此[GitHub 页面上](https://github.com/dfinity/bitcoin-developer-preview)找到有关 API 的详细信息。在回答具有可选 min_confirmations 参数的 get_utxos 和 get_balance 调用时，比特币容器会考虑 UTXO 状态以及至少具有请求的最小确认数的不稳定块中的所有交易。换句话说，在从 UTXO 集合中提取相关的未使用输出后，解析不稳定的块以找到额外的未使用输出。此外，如果有交易消耗任何收集的输出，则输出将被丢弃，因为它们被视为已花费。

为了减少由于分叉导致的不一致的风险，确认被保守地计算，再次使用𝜹-稳定性。块的*稳定性计数*被定义为最大的𝜹，因此块是𝜹稳定的。确定交易确认次数的过程如下： 最大区块高度被识别为在这个高度只有一个区块。考虑到第一步中确定的块的不稳定块链，一个块中交易的确认次数定义为该块的稳定性计数加 1。

虽然这条规则可能看起来很复杂，但它有几个不错的属性： 如果没有分叉，则每笔交易的确认次数正是人们所期望的：一旦交易进入一个区块，它就有一个确认，如果有随后的块，它有两个确认，依此类推。但是，如果存在多个高度相似的竞争分叉，则确认数量将保持在较低水平，直到一条链占上风，此时确认数量开始增加。简而言之，该规则旨在确保基于稳定性计数的大量确认意味着即使存在竞争分叉，交易也不会被撤消的可能性很大。

当比特币容器接收到出站交易并且交易通过验证检查时，它会将交易转发到比特币适配器，如上所述。比特币容器缓存交易并在交易未出现在区块中时定期重新提交。一旦交易出现在区块中或在 24 小时后过期，该交易就会被删除。

### 开发者预览

2022 年 2 月 3 日发布的开发者预览版是比特币集成功能的早期版本。它旨在供开发人员用于开始针对 API 实施智能合约并提供反馈，以便通过社区反馈对最终版本的 API 进行改进。开发者预览版仅作为本地开发环境（Canister SDK）的一部分提供，不与比特币主网或测试网集成。相反，它以模拟真实比特币网络的回归测试（“regtest”）模式运行本地比特币节点（bitcoind），同时完全由开发人员控制。这比用于本地开发环境的比特币网络集成更可取，因为本地比特币节点的确定性行为更适合测试。开发者预览版通过 API get_utxos、get_balance 和 send_transaction 使该功能的所有比特币相关逻辑可用。但是，与 IC 协议栈的集成被简化了：它没有使用与 IC 协议层的自定义集成，特别是共识，而是添加了一个 Adapter Shim 作为外部组件，通过查询调用将 Adapter 连接到常规 IC 协议栈和入口消息。开发者预览版的用户需要在其本地 Canister SDK 环境之上安装该版本并启动它。比特币容器公开为 Wasm 容器，而不是作为副本的一部分实现的虚拟容器，就像最终版本中的管理容器一样。get_balance 和 send_transaction。但是，与 IC 协议栈的集成被简化了：它没有使用与 IC 协议层的自定义集成，特别是共识，而是添加了一个 Adapter Shim 作为外部组件，通过查询调用将 Adapter 连接到常规 IC 协议栈和入口消息。开发者预览版的用户需要在其本地 Canister SDK 环境之上安装该版本并启动它。比特币容器公开为 Wasm 容器，而不是作为副本的一部分实现的虚拟容器，就像最终版本中的管理容器一样。get_balance 和 send_transaction。但是，与 IC 协议栈的集成被简化了：它没有使用与 IC 协议层的自定义集成，特别是共识，而是添加了一个 Adapter Shim 作为外部组件，通过查询调用将 Adapter 连接到常规 IC 协议栈和入口消息。开发者预览版的用户需要在其本地 Canister SDK 环境之上安装该版本并启动它。比特币容器公开为 Wasm 容器，而不是作为副本的一部分实现的虚拟容器，就像最终版本中的管理容器一样。但是添加了一个适配器 Shim 作为外部组件，通过查询调用和入口消息将适配器连接到常规 IC 协议栈。开发者预览版的用户需要在其本地 Canister SDK 环境之上安装该版本并启动它。比特币容器公开为 Wasm 容器，而不是作为副本的一部分实现的虚拟容器，就像最终版本中的管理容器一样。但是添加了一个适配器 Shim 作为外部组件，通过查询调用和入口消息将适配器连接到常规 IC 协议栈。开发者预览版的用户需要在其本地 Canister SDK 环境之上安装该版本并启动它。比特币容器公开为 Wasm 容器，而不是作为副本的一部分实现的虚拟容器，就像最终版本中的管理容器一样。

